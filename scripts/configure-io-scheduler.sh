#!/bin/bash
# BunkerOS I/O Scheduler Optimization
# Automatically detects storage devices and configures optimal I/O schedulers

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
UDEV_RULES_DIR="/etc/udev/rules.d"
UDEV_RULE_FILE="$UDEV_RULES_DIR/60-bunkeros-io-scheduler.rules"

# Colors and formatting
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

info() { echo -e "${BLUE}ℹ️  ${NC}$1"; }
success() { echo -e "${GREEN}✓${NC} $1"; }
warn() { echo -e "${YELLOW}⚠️  ${NC}$1"; }
error() { echo -e "${RED}✗${NC} $1"; }

echo "╔════════════════════════════════════════════════════════════╗"
echo "║         BunkerOS I/O Scheduler Optimization                ║"
echo "╚════════════════════════════════════════════════════════════╝"
echo ""

# Detect storage device type
detect_storage_type() {
    local device="$1"
    local dev_name=$(basename "$device")
    
    # Check if it's an NVMe device
    if [[ "$dev_name" =~ ^nvme ]]; then
        echo "nvme"
        return 0
    fi
    
    # Check if it's rotational (HDD) or non-rotational (SSD)
    if [ -f "/sys/block/$dev_name/queue/rotational" ]; then
        local rotational=$(cat "/sys/block/$dev_name/queue/rotational")
        if [ "$rotational" = "0" ]; then
            echo "ssd"
        else
            echo "hdd"
        fi
        return 0
    fi
    
    echo "unknown"
}

# Get recommended scheduler for device type
get_recommended_scheduler() {
    local device_type="$1"
    
    case "$device_type" in
        nvme)
            # NVMe benefits from none scheduler (direct I/O)
            echo "none"
            ;;
        ssd)
            # SSDs work well with mq-deadline or bfq
            echo "mq-deadline"
            ;;
        hdd)
            # HDDs benefit from BFQ (Budget Fair Queueing)
            echo "bfq"
            ;;
        *)
            echo "mq-deadline"  # Safe default
            ;;
    esac
}

# Detect all block devices
detect_block_devices() {
    local devices=()
    
    # Check for SATA/SCSI devices (sda, sdb, etc.)
    for device in /sys/block/sd*; do
        if [ -e "$device" ]; then
            local dev_name=$(basename "$device")
            # Skip loop devices and removable media
            if [[ ! "$dev_name" =~ ^loop ]] && [ -f "$device/removable" ]; then
                local removable=$(cat "$device/removable")
                if [ "$removable" = "0" ]; then
                    devices+=("$dev_name")
                fi
            fi
        fi
    done
    
    # Check for NVMe devices
    for device in /sys/block/nvme*n*; do
        if [ -e "$device" ]; then
            local dev_name=$(basename "$device")
            # NVMe devices don't have removable flag
            devices+=("$dev_name")
        fi
    done
    
    printf '%s\n' "${devices[@]}"
}

# Display current scheduler information
show_current_schedulers() {
    local devices=("$@")
    
    echo -e "${BOLD}Current I/O Schedulers:${NC}"
    echo ""
    printf "%-15s %-10s %-20s %s\n" "DEVICE" "TYPE" "SCHEDULER" "AVAILABLE"
    printf "%-15s %-10s %-20s %s\n" "───────" "────" "─────────" "─────────"
    
    for dev in "${devices[@]}"; do
        local device_type=$(detect_storage_type "/dev/$dev")
        local scheduler_file="/sys/block/$dev/queue/scheduler"
        
        if [ -f "$scheduler_file" ]; then
            local schedulers=$(cat "$scheduler_file")
            local current=$(echo "$schedulers" | grep -o '\[.*\]' | tr -d '[]')
            local available=$(echo "$schedulers" | sed 's/\[//g; s/\]//g')
            
            printf "%-15s %-10s %-20s %s\n" "$dev" "$device_type" "$current" "$available"
        fi
    done
    
    echo ""
}

# Generate optimized udev rules
generate_udev_rules() {
    info "Generating optimized udev rules..."
    
    cat > /tmp/bunkeros-io-scheduler.rules << 'EOF'
# BunkerOS I/O Scheduler Optimization
# Automatically set optimal I/O schedulers based on storage type
# Generated by configure-io-scheduler.sh

# NVMe devices - use 'none' scheduler for direct I/O (best for NVMe)
ACTION=="add|change", KERNEL=="nvme[0-9]*", ATTR{queue/scheduler}="none"

# SSDs (non-rotational) - use mq-deadline for good latency and throughput
ACTION=="add|change", KERNEL=="sd[a-z]|mmcblk[0-9]*", ATTR{queue/rotational}=="0", ATTR{queue/scheduler}="mq-deadline"

# HDDs (rotational) - use BFQ for better desktop responsiveness
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", ATTR{queue/scheduler}="bfq"

# Also optimize read-ahead for different device types
# NVMe - aggressive read-ahead (they're fast)
ACTION=="add|change", KERNEL=="nvme[0-9]*", ATTR{queue/read_ahead_kb}="256"

# SSD - moderate read-ahead
ACTION=="add|change", KERNEL=="sd[a-z]|mmcblk[0-9]*", ATTR{queue/rotational}=="0", ATTR{queue/read_ahead_kb}="128"

# HDD - conservative read-ahead (avoid unnecessary seeks)
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", ATTR{queue/read_ahead_kb}="128"

# Optimize nr_requests for better performance
# NVMe - higher queue depth
ACTION=="add|change", KERNEL=="nvme[0-9]*", ATTR{queue/nr_requests}="256"

# SSD - moderate queue depth
ACTION=="add|change", KERNEL=="sd[a-z]|mmcblk[0-9]*", ATTR{queue/rotational}=="0", ATTR{queue/nr_requests}="128"

# HDD - conservative queue depth
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", ATTR{queue/nr_requests}="64"
EOF
    
    success "Generated udev rules"
}

# Install udev rules
install_udev_rules() {
    info "Installing udev rules to system..."
    
    if [ ! -d "$UDEV_RULES_DIR" ]; then
        sudo mkdir -p "$UDEV_RULES_DIR"
    fi
    
    sudo cp /tmp/bunkeros-io-scheduler.rules "$UDEV_RULE_FILE"
    sudo chmod 644 "$UDEV_RULE_FILE"
    
    success "Installed: $UDEV_RULE_FILE"
}

# Apply rules immediately (without reboot)
apply_rules_now() {
    info "Applying I/O scheduler optimizations immediately..."
    echo ""
    
    local devices=($(detect_block_devices))
    
    for dev in "${devices[@]}"; do
        local device_type=$(detect_storage_type "/dev/$dev")
        local scheduler=$(get_recommended_scheduler "$device_type")
        local scheduler_file="/sys/block/$dev/queue/scheduler"
        
        if [ -f "$scheduler_file" ]; then
            # Check if scheduler is available
            if grep -q "\b$scheduler\b" "$scheduler_file"; then
                echo "$scheduler" | sudo tee "$scheduler_file" > /dev/null 2>&1
                success "Set $dev ($device_type) → $scheduler"
                
                # Also set read-ahead
                case "$device_type" in
                    nvme)
                        echo "256" | sudo tee "/sys/block/$dev/queue/read_ahead_kb" > /dev/null 2>&1
                        echo "256" | sudo tee "/sys/block/$dev/queue/nr_requests" > /dev/null 2>&1
                        ;;
                    ssd)
                        echo "128" | sudo tee "/sys/block/$dev/queue/read_ahead_kb" > /dev/null 2>&1
                        echo "128" | sudo tee "/sys/block/$dev/queue/nr_requests" > /dev/null 2>&1
                        ;;
                    hdd)
                        echo "128" | sudo tee "/sys/block/$dev/queue/read_ahead_kb" > /dev/null 2>&1
                        echo "64" | sudo tee "/sys/block/$dev/queue/nr_requests" > /dev/null 2>&1
                        ;;
                esac
            else
                warn "Scheduler '$scheduler' not available for $dev, skipping"
            fi
        fi
    done
    
    echo ""
    success "I/O schedulers applied for current session"
}

# Reload udev rules
reload_udev() {
    info "Reloading udev rules..."
    sudo udevadm control --reload-rules
    sudo udevadm trigger --subsystem-match=block
    success "Udev rules reloaded"
}

# Main execution
main() {
    # Detect devices
    info "Detecting storage devices..."
    echo ""
    
    local devices=($(detect_block_devices))
    
    if [ ${#devices[@]} -eq 0 ]; then
        error "No storage devices detected"
        exit 1
    fi
    
    info "Found ${#devices[@]} storage device(s)"
    echo ""
    
    # Show current state
    show_current_schedulers "${devices[@]}"
    
    # Show recommended changes
    echo -e "${BOLD}Recommended I/O Schedulers:${NC}"
    echo ""
    printf "%-15s %-10s %-20s %s\n" "DEVICE" "TYPE" "RECOMMENDED" "REASON"
    printf "%-15s %-10s %-20s %s\n" "───────" "────" "───────────" "──────"
    
    for dev in "${devices[@]}"; do
        local device_type=$(detect_storage_type "/dev/$dev")
        local scheduler=$(get_recommended_scheduler "$device_type")
        
        case "$device_type" in
            nvme)
                local reason="Direct I/O (optimal for NVMe)"
                ;;
            ssd)
                local reason="Low latency, good throughput"
                ;;
            hdd)
                local reason="Fair queuing, reduces seek time"
                ;;
            *)
                local reason="Safe default"
                ;;
        esac
        
        printf "%-15s %-10s %-20s %s\n" "$dev" "$device_type" "$scheduler" "$reason"
    done
    
    echo ""
    
    # Generate and install rules
    generate_udev_rules
    install_udev_rules
    
    echo ""
    
    # Ask to apply now
    read -p "Apply optimizations now without rebooting? (Y/n): " -n 1 -r
    echo ""
    
    if [[ ! $REPLY =~ ^[Nn]$ ]]; then
        apply_rules_now
        reload_udev
    else
        warn "Optimizations will be applied on next boot"
    fi
    
    echo ""
    echo "╔════════════════════════════════════════════════════════════╗"
    echo "║                   Configuration Complete                   ║"
    echo "╚════════════════════════════════════════════════════════════╝"
    echo ""
    success "I/O scheduler optimization configured"
    echo ""
    info "After next boot, verify with:"
    for dev in "${devices[@]}"; do
        echo "  cat /sys/block/$dev/queue/scheduler"
    done
    echo ""
    info "Or run this script again to see current state"
}

# Run if executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
